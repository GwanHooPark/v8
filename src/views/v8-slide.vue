<template>
  <div class="reveal">
    <div class="slides">
      <section class="present" style="display: block;">
        <h1>V8</h1>
        <h2>V8 JavaScript Engine</h2>
        <p>
          <small>비즈서비스 개발팀  <a href="">박관후</a> / <a href="">ghpark@daou.co.kr</a></small>
        </p>
      </section>
      <section>
        <ol>
          <li>JavaScript Engine</li>
          <li>V8 특징</li>
          <li>JavaScript Engine 작동원리</li>
          <li>최적화의 조건</li>
          <li>처리성능 향상 기법</li>
        </ol>
      </section>
      <section>
        <h3>JavaScript Engine 이란?</h3>
        <p>javascript 를 실행하는 프로그램 또는 인터프리터</p>
      </section>
      <section>
        <h3>Javascript 엔진의 종류</h3>
        <ul>
          <li>- SpiderMonkey</li>
          <li>- Rhino </li>
          <li>- Chakra </li>
          <li>- JavaScript Core</li>
          <li>- V8</li>
        </ul>
      </section>
      <section>
        <h3>V8 특징</h3>
        <ul>
          <li>- 2006년 말 만들어진 JavaScript 엔진.</li>
          <li>- 오픈 소스 이며 C++로 만들어짐.</li>
          <li>- Chrome아 아니더라도 독립적으로 실행 가능하다.(Node.js, Electron) </li>
        </ul>
      </section>
      <section>
        <h3>JavaScript 엔진의 작동원리</h3>
        <ul>
          <li>- Just-in-Time Compilation (JITC)</li>
          <li>- JITC보다 interpreter가 더 낫다?</li>
          <li>- Adaptive JIT Compilation</li>
        </ul>
      </section>
      <section><img src="../assets/engine.png"/></section>
      <section><img src="../assets/engine2.png"/></section>
      <section>
        <h3>인터프리터(Ignition)</h3>
        <pre><code class="javascript" data-trim>
          function hello(name) {
            return `Hello, ${name}`;
          }
          console.log(hello('hoo');
        </code></pre>
        <pre><code class="shell" data-trim>
          $ node --print-bytecode hello.js
          [generated bytecode for function: SafeSet (0x02abe12c5871 &lt;SharedFunctionInfo SafeSet&gt;)]
          Parameter count 1
          Register count 5
          Frame size 40
                   000003325AA2BA8E @    0 : 89                CreateRestParameter
                   000003325AA2BA8F @    1 : 26 f9             Star r2
                   000003325AA2BA91 @    3 : 27 fe fa          Mov &lt;closure&gt;, r1
           3153 E> 000003325AA2BA94 @    6 : a7                StackCheck
           3153 S> 000003325AA2BA95 @    7 : 25 fa             Ldar r1
                   000003325AA2BA97 @    9 : 55 f7             GetSuperConstructor r4
                   000003325AA2BA99 @   11 : 25 fb             Ldar r0
           3153 E> 000003325AA2BA9B @   13 : 66 f7 f9 01 00    ConstructWithSpread r4, r2-r2, [0]
           3153 S> 000003325AA2BAA0 @   18 : ab                Return
          Constant pool (size = 0)
          Handler Table (size = 0)
        </code></pre>
      </section>
      <section>
        <h3>Optimizing Compiler(TurboFan)</h3>
        <pre><code class="javascript" data-trim>
          function test() {
              const array = Array.from(arguments);
              return array.map(el => el * el)
                          .filter(el => el &lt; 20)
                          .reverse();
          }
          for (let i=0; i &lt; 100000; i++) {
              test(1,2,3,4,5);
          }
        </code></pre>
        <pre><code class="shell" data-trim data-line-numbers="1,2,11">
          $ node --trace-opt test.js
          [marking 0x02f422f09221 &lt;JSFunction (sfi = 00000021CFCD0F39)&gt; for optimized recompilation, reason: small function]
          [marking 0x0303a76b3b21 &lt;JSFunction (sfi = 00000021CFCD1891)&gt; for optimized recompilation, reason: small function]
          [compiling method 0x0303a76b3b21 &lt;JSFunction (sfi = 00000021CFCD1891)&gt; using TurboFan]
          [marking 0x0303a76b3bb1 &lt;JSFunction (sfi = 00000021CFCD18E1)&gt; for optimized recompilation, reason: small function]
          [compiling method 0x0303a76b3bb1 &lt;JSFunction (sfi = 00000021CFCD18E1)&gt; using TurboFan]
          [optimizing 0x0303a76b3b21 &lt;JSFunction (sfi = 00000021CFCD1891)&gt; - took 0.349, 0.382, 0.021 ms]
          [completed optimizing 0x0303a76b3b21 &lt;JSFunction (sfi = 00000021CFCD1891)&gt;]
          [optimizing 0x0303a76b3bb1 &lt;JSFunction (sfi = 00000021CFCD18E1)&gt; - took 0.095, 0.203, 0.012 ms]
          [completed optimizing 0x0303a76b3bb1 &lt;JSFunction (sfi = 00000021CFCD18E1)&gt;]
          [marking 0x02f422f091e1 &lt;JSFunction test (sfi = 00000021CFCD1001)&gt; for optimized recompilation, reason: hot and stable]
          [compiling method 0x02f422f091e1 &lt;JSFunction test (sfi = 00000021CFCD1001)&gt; using TurboFan]
        </code></pre>
      </section>
      <section>
        <h4>https://github.com/v8/v8/blob/master/src/execution/runtime-profiler.cc</h4>
        <pre><code class="javascript" data-trim data-line-numbers="8,9,10,11,12,13,14">
          OptimizationReason RuntimeProfiler::ShouldOptimize(JSFunction function,
                                                   BytecodeArray bytecode) {
          if (function.HasOptimizedCode()) return OptimizationReason::kDoNotOptimize;
          int ticks = function.feedback_vector().profiler_ticks();
          int ticks_for_optimization =
              kProfilerTicksBeforeOptimization +
              (bytecode.length() / kBytecodeSizeAllowancePerTick);
          if (ticks >= ticks_for_optimization) {
            return OptimizationReason::kHotAndStable;
          } else if (!any_ic_changed_ &&
                     bytecode.length() &lt; kMaxBytecodeSizeForEarlyOpt) {
            // If no IC was patched since the last tick and this function is very
            // small, optimistically optimize it now.
            return OptimizationReason::kSmallFunction;
          } else if (FLAG_trace_opt_verbose) {
            PrintF("[not yet optimizing ");
            function.PrintName();
            PrintF(", not enough ticks: %d/%d and ", ticks,
                   kProfilerTicksBeforeOptimization);
            if (any_ic_changed_) {
              PrintF("ICs changed]\n");
            } else {
              PrintF(" too large for small function optimization: %d/%d]\n",
                     bytecode.length(), kMaxBytecodeSizeForEarlyOpt);
            }
          }
          return OptimizationReason::kDoNotOptimize;
        }
        </code></pre>
      </section>
      <section>
        <h3>Hidden Class</h3>
        <img src="../assets/hiddenclass.png"/>
      </section>
      <section>
        <h3>Inline Caching</h3>
        <pre><code class="javascript" data-trim>
          // Inline Caching
          function hello(user) {
            return `Hello, ${user.firstName} ${user.lastName}`;
          }
          const user = {
            firstName : 'gwanhoo',
            lastName : 'park'
          }
          hello(user); // 'Hello. park gwanhoo' 로 대체됩니다.
        </code></pre>
      </section>
      <section>
        <h3>Inline Caching</h3>
        <pre><code class="javascript" data-trim>
          // Inline Caching
          for (let i=0; i&lt;10; i++) {
            arr[i].x = i;
          }
        </code></pre>
      </section>
      <section>
        <h3>어떻게 최적화된 자바스크립트 코드를 작성할 것인가.</h3>
        <p>
          변수 스코프
          가볍고 적은 코드
          쓸데없는 반복문 쓰지 않기
          쓸데없는 반복문 쓰지 않기
          이벤트 위임
          Gzip 압축
          객체를 캐싱하여 성능 향상

          똑같은 코드여도 실행환경에 따라 퍼포먼스는 천차만별이다.
          각기다른 자바스크립트 엔진을 사용하는 브라우저가 서로 다른 결과를 내는 것은 어쩌면 아주 당연한 일일지도 모른다.
          구현방법에 대한 표준화가 딱히 이루어져있는 것은 아닐테니까 말이다.
        </p>
      </section>
    </div>
  </div>
</template>
<script>
import Reveal from 'reveal.js/dist/reveal'
import RevealMarkdown from 'reveal.js/plugin/markdown/markdown'
import RevealHighLight from 'reveal.js/plugin/highlight/highlight'
export default {
  name: 'V8Engine',
  mounted() {
    Reveal.initialize({
      plugins: [ RevealMarkdown, RevealHighLight]
    })
  }
}
</script>