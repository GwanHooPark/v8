<template>
  <div class="reveal">
    <div class="title" id="title"></div>
    <div class="slides">
      <section class="present" style="display: block;">
        <h1>V8</h1>
        <h2>V8 JavaScript Engine</h2>
        <p>
          <small>비즈서비스 개발팀  <a href="">박관후</a> / <a href="">ghpark@daou.co.kr</a></small>
        </p>
      </section>
      <section data-title="Index">
        <ol>
          <li>JavaScript Engine</li>
          <li>JavaScript Engine 작동원리</li>
          <li>최적화의 조건</li>
          <li>처리성능 향상을 위한 방법</li>
        </ol>
      </section>
      <section data-title="1.JS Engine">
        <h3>JavaScript Engine 이란?</h3>
        <p>javascript 를 실행하는 프로그램 또는 인터프리터</p>
      </section>
      <section data-title="1.JS Engine">
        <h3>Javascript 엔진의 종류</h3>
        <ul>
          <li>- SpiderMonkey</li>
          <li>- Rhino </li>
          <li>- Chakra </li>
          <li>- JavaScript Core</li>
          <li>- V8</li>
        </ul>
      </section>
      <section data-title="1.JS Engine">
        <h3>V8 특징</h3>
        <ul>
          <li>- 2006년 말 만들어진 JavaScript 엔진.</li>
          <li>- 오픈 소스 이며 C++로 만들어짐.</li>
          <li>- Chrome아 아니더라도 독립적으로 실행 가능하다.(Node.js, Electron) </li>
        </ul>
      </section>
      <section data-title="2.JS Engine 작동원리">
        <h3>JavaScript 엔진의 작동원리</h3>
        <p>Just-in-Time Compilation (JITC)</p>
      </section>
      <section data-title="2.JS Engine 작동원리">
        <p>JITC or interpreter ?</p>
      </section>
      <section data-title="2.JS Engine 작동원리">
        <p>
          JITC + interpreter =
          Adaptive JIT Compilation
        </p>
      </section>
      <section data-title="2.JS Engine 작동원리(공통)">
        <img src="../assets/engine.png"/>
      </section>
      <section data-title="2.JS Engine 작동원리(V8)">
        <img src="../assets/engine3.png"/>
      </section>
      <section data-title="2.JS Engine 작동원리">
        <h3>인터프리터(Ignition)</h3>
        <pre><code class="javascript" data-trim>
          function hello(name) {
            return `Hello, ${name}`;
          }
          console.log(hello('hoo');
        </code></pre>
        <pre><code class="shell" data-trim>
          $ node --print-bytecode hello.js
          [generated bytecode for function: SafeSet (0x02abe12c5871 &lt;SharedFunctionInfo SafeSet&gt;)]
          Parameter count 1
          Register count 5
          Frame size 40
                   000003325AA2BA8E @    0 : 89                CreateRestParameter
                   000003325AA2BA8F @    1 : 26 f9             Star r2
                   000003325AA2BA91 @    3 : 27 fe fa          Mov &lt;closure&gt;, r1
           3153 E> 000003325AA2BA94 @    6 : a7                StackCheck
           3153 S> 000003325AA2BA95 @    7 : 25 fa             Ldar r1
                   000003325AA2BA97 @    9 : 55 f7             GetSuperConstructor r4
                   000003325AA2BA99 @   11 : 25 fb             Ldar r0
           3153 E> 000003325AA2BA9B @   13 : 66 f7 f9 01 00    ConstructWithSpread r4, r2-r2, [0]
           3153 S> 000003325AA2BAA0 @   18 : ab                Return
          Constant pool (size = 0)
          Handler Table (size = 0)
        </code></pre>
      </section>
      <section data-title="2.JS Engine 작동원리">
        <h3>Optimizing Compiler(TurboFan)</h3>
        <pre><code class="javascript" data-trim>
          function test() {
              const array = Array.from(arguments);
              return array.map(el => el * el)
                          .filter(el => el &lt; 20)
                          .reverse();
          }
          for (let i=0; i &lt; 100000; i++) {
              test(1,2,3,4,5);
          }
        </code></pre>
        <pre><code class="shell" data-trim data-line-numbers="1,2,11">
          $ node --trace-opt test.js
          [marking 0x02f422f09221 &lt;JSFunction (sfi = 00000021CFCD0F39)&gt; for optimized recompilation, reason: small function]
          [marking 0x0303a76b3b21 &lt;JSFunction (sfi = 00000021CFCD1891)&gt; for optimized recompilation, reason: small function]
          [compiling method 0x0303a76b3b21 &lt;JSFunction (sfi = 00000021CFCD1891)&gt; using TurboFan]
          [marking 0x0303a76b3bb1 &lt;JSFunction (sfi = 00000021CFCD18E1)&gt; for optimized recompilation, reason: small function]
          [compiling method 0x0303a76b3bb1 &lt;JSFunction (sfi = 00000021CFCD18E1)&gt; using TurboFan]
          [optimizing 0x0303a76b3b21 &lt;JSFunction (sfi = 00000021CFCD1891)&gt; - took 0.349, 0.382, 0.021 ms]
          [completed optimizing 0x0303a76b3b21 &lt;JSFunction (sfi = 00000021CFCD1891)&gt;]
          [optimizing 0x0303a76b3bb1 &lt;JSFunction (sfi = 00000021CFCD18E1)&gt; - took 0.095, 0.203, 0.012 ms]
          [completed optimizing 0x0303a76b3bb1 &lt;JSFunction (sfi = 00000021CFCD18E1)&gt;]
          [marking 0x02f422f091e1 &lt;JSFunction test (sfi = 00000021CFCD1001)&gt; for optimized recompilation, reason: hot and stable]
          [compiling method 0x02f422f091e1 &lt;JSFunction test (sfi = 00000021CFCD1001)&gt; using TurboFan]
        </code></pre>
      </section>
      <section data-title="3.최적화의 조건">
        <h4>https://github.com/v8/v8/blob/master/src/execution/runtime-profiler.cc</h4>
        <pre><code class="javascript" data-trim data-line-numbers="8,9,10,11,12,13,14">
          OptimizationReason RuntimeProfiler::ShouldOptimize(JSFunction function,
                                                   BytecodeArray bytecode) {
          if (function.HasOptimizedCode()) return OptimizationReason::kDoNotOptimize;
          int ticks = function.feedback_vector().profiler_ticks();
          int ticks_for_optimization =
              kProfilerTicksBeforeOptimization +
              (bytecode.length() / kBytecodeSizeAllowancePerTick);
          if (ticks >= ticks_for_optimization) {
            return OptimizationReason::kHotAndStable;
          } else if (!any_ic_changed_ &&
                     bytecode.length() &lt; kMaxBytecodeSizeForEarlyOpt) {
            // If no IC was patched since the last tick and this function is very
            // small, optimistically optimize it now.
            return OptimizationReason::kSmallFunction;
          } else if (FLAG_trace_opt_verbose) {
            PrintF("[not yet optimizing ");
            function.PrintName();
            PrintF(", not enough ticks: %d/%d and ", ticks,
                   kProfilerTicksBeforeOptimization);
            if (any_ic_changed_) {
              PrintF("ICs changed]\n");
            } else {
              PrintF(" too large for small function optimization: %d/%d]\n",
                     bytecode.length(), kMaxBytecodeSizeForEarlyOpt);
            }
          }
          return OptimizationReason::kDoNotOptimize;
        }
        </code></pre>
      </section>
      <section data-title="3.최적화의 조건">
        <h4>Hidden Class</h4>
        <img src="../assets/hiddenclass.png"/>
      </section>
      <section data-title="3.최적화의 조건">
        <h3>Inline Caching</h3>
        <pre><code class="javascript" data-trim>
          // Inline Caching
          function hello(user) {
            return `Hello, ${user.firstName} ${user.lastName}`;
          }
          const user = {
            firstName : 'hoo',
            lastName : 'park'
          }
          hello(user); // 'Hello. park hoo' 로 대체됩니다.
        </code></pre>
      </section>
      <section data-title="3.최적화의 조건">
        <h3>Inline Caching</h3>
        <pre><code class="javascript" data-trim>
          // Inline Caching
          for (let i=0; i&lt;10; i++) {
            arr[i].x = i;
          }
        </code></pre>
      </section>
      <section data-title="4.처리성능 향상 방법">
        <h3>어떻게 최적화된 자바스크립트 코드를 작성할 것인가.</h3>
        <ul>
          <li>- 자바스크립트를 동적인 언어라고 생각하고 쓰면 좋다.</li>
          <li>- 동적인 특성을 최대한 활용하는것도 좋지만 성능저하가 일어날수 있다는 점을 염두해야한다.</li>
        </ul>
      </section>
      <section>
        <h3>감사합니다.</h3>
      </section>
    </div>
  </div>
</template>
<script>
  import Reveal from 'reveal.js/dist/reveal'
  import RevealMarkdown from 'reveal.js/plugin/markdown/markdown'
  import RevealHighLight from 'reveal.js/plugin/highlight/highlight'
  export default {
    name: 'V8Engine',
    mounted() {
      Reveal.initialize({
        plugins: [ RevealMarkdown, RevealHighLight]
      });
      Reveal.on( 'slidechanged', event => {
        console.log(event.currentSlide);
        var target = event.currentSlide;
        document.getElementById("title").innerText = target.getAttribute("data-title");
      } );
    }
  }
</script>